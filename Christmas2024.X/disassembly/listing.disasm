Disassembly Listing for Christmas2024
Generated From:
E:/ProgrammingToo/Experimentation/Christmas2024/Christmas2024.X/dist/default/production/Christmas2024.X.production.elf
Oct 1, 2024 12:42:04 PM

---  E:/ProgrammingToo/Experimentation/Christmas2024/Christmas2024.X/main.c  ----------------------------
1:             #include "common.h" // MUST come first due to pragmas
2:             #include <math.h>
3:             #include <stdint.h>
4:             #include <stdbool.h>
5:             #include <limits.h>
6:             
7:             // Macros and constants
8:             
9:             // Typedefs 
10:            
11:            // Private variables
12:            // Goes true when Timer 0 has expired
13:            static bool mUnhandledSystemTick = false;
14:            
15:            // Whether the fast (non-LF) system clock is currently being used
16:            static bool mSystemFastClock = false;
17:            
18:            static uint8_t mLedCounter = 0;
19:            
20:            // Function implementations
21:            
22:            // Setup of the pins and peripherals
23:            void setup(void)
24:            {   
25:                //
26:                // GPIO
27:                //
28:                
29:                // Initialization states
30:                PORTB = 0;
001C  018D     CLRF PORTB
31:                
32:                // Input/output states (default = input)
33:                TRISBbits.TRISB0 = 0; // RB0 = output
001D  1012     BCF TRISB, 0x0
34:                
35:                // Analog/digital
36:                ANSELBbits.ANSB0 = 0; // RB0 = digital
001E  003E     MOVLB 0x1E
001F  1043     BCF ANSELB, 0x0
37:                
38:                // Slew rate
39:                SLRCONB = 0xFF; // limit all PORTB
0020  30FF     MOVLW 0xFF
0021  00C6     MOVWF SLRCONB
40:                
41:                //
42:                // Timers
43:                //
44:                
45:                // Timer0 -- System tick
46:                T0CON1bits.T0CS = 0b0100; // clock source = LFINTOSC (31 kHz))
0022  0020     MOVLB 0x0
0023  081F     MOVF T0CON1, W
0024  391F     ANDLW 0x1F
0025  3880     IORLW 0x80
0026  009F     MOVWF T0CON1
47:                T0CON1bits.T0CKPS = 0b1001; // prescaler = 512 (for 60.5 Hz base rate)
0027  081F     MOVF T0CON1, W
0028  39F0     ANDLW 0xF0
0029  3809     IORLW 0x9
002A  009F     MOVWF T0CON1
48:                T0CON0bits.T0OUTPS = 0; // postscaler = 1
002B  30F0     MOVLW 0xF0
002C  059E     ANDWF T0CON0, F
49:                T0EN = 0; // Timer off for now
002D  139E     BCF T0CON0, 0x7
50:                TMR0IF = 0; // Clear interrupt flag
002E  002E     MOVLB 0xE
002F  128C     BCF PIR0, 0x5
51:                TMR0IE = 1; // Enable interrupts
0030  1696     BSF PIE0, 0x5
52:                TMR0L = 0; // Initialize timer count to zero
0031  0020     MOVLB 0x0
0032  019C     CLRF TMR0L
53:                TMR0H = 1; // interrupt every other tick, roughly every 32 ms
0033  3001     MOVLW 0x1
0034  009D     MOVWF TMR0H
54:                
55:                
56:                // Ensure HFINTOSC is at 16 MHz
57:                OSCFRQbits.HFFRQ = 0b101;
0035  0031     MOVLB 0x11
0036  0813     MOVF OSCFRQ, W
0037  39F8     ANDLW 0xF8
0038  3805     IORLW 0x5
0039  0093     MOVWF OSCFRQ
58:                
59:                // Ensure FOSC is LFINTOSC/2
60:                OSCCON1bits.NOSC = 0b101; // LFINTOSC, 31 kHz
003A  080D     MOVF OSCCON1, W
003B  398F     ANDLW 0x8F
003C  3850     IORLW 0x50
003D  008D     MOVWF OSCCON1
61:                OSCCON1bits.NDIV = 0b0001; // Divide by 2 = net 15.5 kHz system osc
003E  080D     MOVF OSCCON1, W
003F  39F0     ANDLW 0xF0
0040  3801     IORLW 0x1
0041  008D     MOVWF OSCCON1
62:                
63:                // Enable idle mode
64:                CPUDOZEbits.IDLEN = 1;
0042  178C     BSF CPUDOZE, 0x7
65:                
66:                // General peripheral interrupt enable
67:                PEIE = 1;
0043  170B     BSF INTCON, 0x6
68:                
69:                // Enable watchdog timer
70:                WDTCON0bits.SWDTEN = 1;
0044  0030     MOVLB 0x10
0045  140C     BSF WDTCON0, 0x0
71:                
72:                // Enable systick
73:                T0EN = 1;
0046  0020     MOVLB 0x0
0047  179E     BSF T0CON0, 0x7
74:            }
0048  0008     RETURN
75:            
76:            // Allow the system clock to be switched back and forth between 15.5 kHz and 16 MHz
77:            // Handles all of the timer clock divider changes so that items based on Fosc
78:            // continue operating normally.
79:            void switchSystemClock(bool fast)
0049  00F4     MOVWF fast
005E  00F3     MOVWF __pcstackCOMMON
80:            {
81:                // Early return if there is no change
82:                if (fast == mSystemFastClock)
004A  0874     MOVF fast, W
004B  0671     XORWF mSystemFastClock, W
004C  1903     BTFSC STATUS, 0x2
004D  0008     RETURN
005F  0873     MOVF __pcstackCOMMON, W
0060  0671     XORWF mSystemFastClock, W
0061  1903     BTFSC STATUS, 0x2
0062  0008     RETURN
83:                {
84:                    return;
85:                }
86:                    
87:                if (fast)
004E  0874     MOVF fast, W
004F  1903     BTFSC STATUS, 0x2
0050  2859     GOTO 0x59
0063  0873     MOVF __pcstackCOMMON, W
0064  1903     BTFSC STATUS, 0x2
0065  286E     GOTO 0x6E
88:                {
89:                    // Splitting the mSystemFastClock assignment like this saves two instruction 
90:                    // cycles versus the more obvious method of assigning it the value of "fast"
91:                    // before the conditional block
92:                    mSystemFastClock = true;
0051  01F1     CLRF mSystemFastClock
0052  0AF1     INCF mSystemFastClock, F
0066  01F1     CLRF mSystemFastClock
0067  0AF1     INCF mSystemFastClock, F
93:                
94:                    // Switch to fast clock
95:                    // TODO: Was earlier testing done with HFINTOSC still divided by 2?
96:                    OSCCON1 = 0b110 << 4 | 0b0000; // HFINTOSC, which we configured to be 16 MHz in setup()
0053  3060     MOVLW 0x60
0054  0031     MOVLB 0x11
0055  008D     MOVWF OSCCON1
0068  3060     MOVLW 0x60
0069  0031     MOVLB 0x11
006A  008D     MOVWF OSCCON1
97:                    while (!OSCCON3bits.ORDY);
0056  1A0F     BTFSC OSCCON3, 0x4
0057  0008     RETURN
0058  2856     GOTO 0x56
006B  1A0F     BTFSC OSCCON3, 0x4
006C  0008     RETURN
006D  286B     GOTO 0x6B
98:                }
99:                else
100:               {
101:                   // Splitting the mSystemFastClock assignment like this saves two instruction 
102:                   // cycles versus the more obvious method of assigning it the value of "fast"
103:                   // before the conditional block
104:                   mSystemFastClock = false;
0059  01F1     CLRF 0x8F1
006E  01F1     CLRF 0x8F1
105:               
106:                   // Switch to slow clock, which is always ready
107:                   OSCCON1 = 0b101 << 4 | 0b0001; // LFINTOSC, divide by 2. Net = 15.5 kHz
005A  3051     MOVLW 0x51
005B  0031     MOVLB 0x11
005C  008D     MOVWF OSCCON1
006F  3051     MOVLW 0x51
0070  0031     MOVLB 0x11
0071  008D     MOVWF OSCCON1
108:               }
109:           }
005D  0008     RETURN
0072  0008     RETURN
110:           
111:           void system_tick_handler(void)
112:           {
113:               // TODO
114:               if (mLedCounter == 0)
0073  0870     MOVF 0x8F0, W
0074  1D03     BTFSS STATUS, 0x2
0075  287A     GOTO 0x7A
115:               {
116:                   // LED on
117:                   PORTB = 0x01;
0076  3001     MOVLW 0x1
0077  0020     MOVLB 0x0
0078  008D     MOVWF PORTB
118:               }
0079  287C     GOTO 0x7C
119:               else
120:               {
121:                   // LED off
122:                   PORTB = 0x00;
007A  0020     MOVLB 0x0
007B  018D     CLRF PORTB
123:               }
124:               
125:               mLedCounter++;
007C  3001     MOVLW 0x1
007D  00F4     MOVWF fast
007E  0874     MOVF fast, W
007F  07F0     ADDWF mLedCounter, F
126:               mLedCounter &= 0x0F; // blink every time this wraps, about twice per second
0080  300F     MOVLW 0xF
0081  00F4     MOVWF fast
0082  0874     MOVF fast, W
0083  05F0     ANDWF mLedCounter, F
127:               
128:               // Pet watchdog
129:               // (The watchdog is automatically pet when going to sleep, so maybe this is unneeded?)
130:               CLRWDT();
0084  0064     CLRWDT
131:           }
0085  0008     RETURN
132:           
133:           void main(void)
134:           {
135:               di();
0086  138B     BCF INTCON, 0x7
136:               setup();
0087  3180     MOVLP 0x0
0088  201C     CALL 0x1C
0089  3180     MOVLP 0x0
137:               ei();
008A  178B     BSF INTCON, 0x7
138:               
139:               // Loop forever
140:               while(true)
141:               {
142:                   if (mUnhandledSystemTick)
008B  0872     MOVF mUnhandledSystemTick, W
008C  1903     BTFSC STATUS, 0x2
008D  2896     GOTO 0x96
143:                   {   
144:                       mUnhandledSystemTick = false;
008E  01F2     CLRF mUnhandledSystemTick
145:                       
146:                       // Do the appropriate actions for the current state
147:                       system_tick_handler();
008F  3180     MOVLP 0x0
0090  2073     CALL 0x73
0091  3180     MOVLP 0x0
148:                       
149:                       switchSystemClock(false);
0092  3000     MOVLW 0x0
0093  3180     MOVLP 0x0
0094  2049     CALL 0x49
0095  3180     MOVLP 0x0
150:                   }
151:           
152:                   // Wait for next interrupt
153:                   SLEEP();
0096  0063     SLEEP
154:               }
155:           }
156:           
157:           // Interrupt handler. 
158:           // On the PIC16, there is only one interrupt vector, so we need to search
159:           // through the interrupt flags to figure out which one we got
160:           void __interrupt() isr(void)
0004  147E     BSF btemp, 0x0
0005  3180     MOVLP 0x0
161:           {    
162:               // Timer 0 -- System tick timer
163:               if (TMR0IE && TMR0IF)
0006  002E     MOVLB 0xE
0007  1A96     BTFSC PIE0, 0x5
0008  1E8C     BTFSS PIR0, 0x5
0009  2811     GOTO 0x11
164:               {
165:                   // Speed up system clock as soon as possible
166:                   switchSystemClock(true);
000A  3001     MOVLW 0x1
000B  3180     MOVLP 0x0
000C  205E     CALL 0x5E
167:                   
168:                   mUnhandledSystemTick = true;
000D  01F2     CLRF 0x772
000E  0AF2     INCF 0x772, F
169:           
170:                   TMR0IF = 0;
000F  002E     MOVLB 0xE
0010  128C     BCF PIR0, 0x5
171:                   // Timer auto-reloads
172:               }
173:            
174:               return;
175:           }
0011  107E     BCF 0x77E, 0x0
---  C:/Users/jeff/AppData/Local/Temp/xcAs1670.s  -------------------------------------------------------
0015  01F0     CLRF 0x770
0016  01F1     CLRF 0x771
0017  01F2     CLRF 0x772
0018  107E     BCF 0x77E, 0x0
0019  0020     MOVLB 0x0
001A  3180     MOVLP 0x0
