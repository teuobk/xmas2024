<!DOCTYPE html>
<html>
<head>
    <title>Data Transmission Tool</title>
</head>
<body>
    <button id="startButton">Start</button>
    <button id="stopButton" disabled>Stop</button>
    <br><br>
    <input type="text" id="dataInput" value="0" maxlength="1" size="1">
    <button id="sendButton" disabled>Send</button>

    <script type="text/javascript">
        (function() {
            var startButton = document.getElementById('startButton');
            var stopButton = document.getElementById('stopButton');
            var sendButton = document.getElementById('sendButton');
            var dataInput = document.getElementById('dataInput');

            var isRunning = false;
            var isTransmittingData = false;
            var startTime = 0;
            var maxDuration = 30000; // 30 seconds
            var socket = null;
            var carrierTimerId = null;
            var symbolIndex = 0;
            var symbols = [];
            var previousPhase = 0; // 0 for normal phase, 1 for reversed phase

            startButton.addEventListener('click', function() {
                startTransmission();
            });

            stopButton.addEventListener('click', function() {
                stop();
            });

            sendButton.addEventListener('click', function() {
                sendData();
            });

            function startTransmission() {
                if (isRunning) return;

                startButton.disabled = true;
                stopButton.disabled = false;
                sendButton.disabled = false;
                isRunning = true;
                startTime = Date.now();

                // Connect to the secure WebSocket server
                socket = new WebSocket('wss://keacher.com:8080');

                socket.onopen = function() {
                    console.log('WebSocket connection established.');
                    startCarrier();
                };

                socket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                };

                socket.onclose = function() {
                    console.log('WebSocket connection closed.');
                    stop();
                };
            }

            function stop() {
                if (!isRunning) return;

                isRunning = false;
                isTransmittingData = false;
                startButton.disabled = false;
                stopButton.disabled = true;
                sendButton.disabled = true;

                if (carrierTimerId !== null) {
                    clearTimeout(carrierTimerId);
                    carrierTimerId = null;
                }

                if (socket) {
                    socket.close();
                    socket = null;
                }
            }

            function startCarrier() {
                if (!isRunning || isTransmittingData) return;

                // Start sending carrier continuously
                sendCarrierData();
            }

            function sendCarrierData() {
                if (!isRunning || isTransmittingData) return;

                if (socket && socket.readyState === WebSocket.OPEN && socket.bufferedAmount === 0) {
                    // Send data
                    var size = 5 * 1024; // 5 KB
                    var data = generatePrintableData(size);
                    socket.send(data);
                }

                // Continue sending data as fast as possible
                carrierTimerId = setTimeout(sendCarrierData, 0);
            }

            function sendData() {
                if (!isRunning || isTransmittingData) return;
                sendButton.disabled = true;
                var hexValue = dataInput.value.trim();
                if (!/^[0-9A-Fa-f]$/.test(hexValue)) {
                    alert('Please enter a valid hexadecimal digit (0-9, A-F).');
                    return;
                }

                // Stop carrier transmission
                if (carrierTimerId !== null) {
                    clearTimeout(carrierTimerId);
                    carrierTimerId = null;
                }

                isTransmittingData = true;
                symbolIndex = 0;
                
                // Encode data
                var nibble = parseInt(hexValue, 16) & 0xF; // 4 bits
                var encodedData = hammingEncode(nibble); // 8 bits array

                console.log("Hamming[8,4] encoded %d: " + JSON.stringify(encodedData), nibble);

                // Create preamble (length-2 Barker code)
                // Barker code for length 2 is [+1, -1]
	        // but make it longer to have 300 ms high low sections
                var preamble = [0,1];
                
                // Create symbols array
                // Map preamble to symbols
                symbols = preamble.map(function(value) {
                    return value;
                });

                // Differential encoding for data bits
                for (var i = 0; i < encodedData.length; i++) {
                    var bit = encodedData[i];
                    symbols.push(bit);
                }

                console.log("Phase symbols including 2-Barker prefix: " + JSON.stringify(symbols));

                // Start transmitting symbols
                transmitSymbol();
            }

            function transmitSymbol() {
                if (!isRunning || !isTransmittingData) {
                    // Resume carrier transmission
                    isTransmittingData = false;
                    startCarrier();
                    return;
                }

                if (symbolIndex >= symbols.length) {
                    // Data transmission complete
                    isTransmittingData = false;
                    sendButton.disabled = false;
                    startCarrier();
                    return;
                }

                var symbol = symbols[symbolIndex];
                symbolIndex++;

                var onDuration = 150;
                var offDuration = 150;

                var firstPeriodIsOn = (symbol === 0);

                // Call transmitOnOff with durations and firstPeriodIsOn
                transmitOnOff(onDuration, offDuration, firstPeriodIsOn, transmitSymbol);
            }

            function transmitOnOff(firstDuration, secondDuration, isFirstPeriodOn, callback) {
                var firstStartTime = Date.now();

                function firstPeriod() {
                    if (!isRunning || !isTransmittingData) return;

                    var now = Date.now();
                    if (now - firstStartTime >= firstDuration) {
                        // First period over, start second period
                        secondPeriod();
                        return;
                    }

                    if (isFirstPeriodOn) {
                        if (socket && socket.readyState === WebSocket.OPEN && socket.bufferedAmount === 0) {
                            // Send data during "on" period
                            var size = 5 * 1024; // 5 KB
                            var data = generatePrintableData(size);
                            socket.send(data);
                        }
                    }

                    // Continue during first period
                    setTimeout(firstPeriod, 0);
                }

                function secondPeriod() {
                    var secondStartTime = Date.now();

                    function secondPeriodInner() {
                        if (!isRunning || !isTransmittingData) return;

                        var now = Date.now();
                        if (now - secondStartTime >= secondDuration) {
                            // Second period over, proceed to next symbol
                            callback();
                            return;
                        }

                        if (!isFirstPeriodOn) {
                            if (socket && socket.readyState === WebSocket.OPEN && socket.bufferedAmount === 0) {
                                // Send data during "on" period
                                var size = 5 * 1024; // 5 KB
                                var data = generatePrintableData(size);
                                socket.send(data);
                            }
                        }

                        // Continue during second period
                        setTimeout(secondPeriodInner, 0);
                    }

                    secondPeriodInner();
                }

                firstPeriod();
            }

            function hammingEncode(nibble) {
                // [8,4] Extended Hamming code
                // Positions: [p1, p2, d1, p3, d2, d3, d4, p4]
                var d = [
                    (nibble >> 3) & 1, // d1 (MSB)
                    (nibble >> 2) & 1, // d2
                    (nibble >> 1) & 1, // d3
                    (nibble >> 0) & 1  // d4 (LSB)
                ];

                var p1 = d[0] ^ d[1] ^ d[3];
                var p2 = d[0] ^ d[2] ^ d[3];
                var p3 = d[1] ^ d[2] ^ d[3];
                var p4 = p1 ^ p2 ^ p3 ^ d[0] ^ d[1] ^ d[2] ^ d[3]; // Overall parity bit

                var encoded = [p1, p2, d[0], p3, d[1], d[2], d[3], p4];
                return encoded;
            }

            function generatePrintableData(size) {
                var array = new Uint8Array(size);
                window.crypto.getRandomValues(array);
                for (var i = 0; i < array.length; i++) {
                    array[i] = 32 + (array[i] % 95); // Map to ASCII 32-126
                }
                return arrayToString(array);
            }

            function arrayToString(array) {
                var chunkSize = 0x8000; // 32KB chunks for performance
                var chunks = [];
                for (var i = 0; i < array.length; i += chunkSize) {
                    chunks.push(String.fromCharCode.apply(null, array.subarray(i, i + chunkSize)));
                }
                return chunks.join('');
            }

        })();
    </script>
</body>
</html>
